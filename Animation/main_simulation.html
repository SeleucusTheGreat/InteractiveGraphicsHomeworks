<!doctype html>
<html>
<head>
<title>WebGL Physics Spheres</title>
<link rel="stylesheet" href="style.css">
</head>
<body onresize="WindowResize()">
<div style="position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(255,255,255,0.8); padding: 5px; border-radius: 5px;">
    <div>
        <button onclick="ResetPositions()">Reset Objects</button>
    </div>
</div>
<div id="canvas-div"><canvas id="canvas"></canvas></div>
</div>
<script type="text/javascript" src="gl-matrix.js"></script>
<script type="text/javascript" id="includedscript" src="matrix.js"></script>
<script type="text/javascript" id="includedscript" src="box.js"></script>
<script type="text/javascript" src="ball_drawer.js"></script>
<script type="text/javascript" src="physics.js"></script>
<script type="text/javascript" src="ball.js"></script>
<script type="text/javascript">

const { mat4, vec3, vec4 } = glMatrix;
	
var meshInstances = [];
const NUM_INSTANCES = 50; 
const SPHERE_RADIOUS = 0.08
var boxDrawer;
var ballDrawer;
var canvas, gl;
var perspectiveMatrix = mat4.create();	
var rotX=0, rotY=0, transZ=5 
var lastTime = 0; 

var viewProjMatrix; 
var viewMatrix; // Add view matrix
const mouseState = {
    x: -1, y: -1,     
    worldX: 0, worldY: 0, worldZ: 0,
    velX: 0, velY: 0, velZ: 0,
    lastWorldX: 0, lastWorldY: 0, lastWorldZ: 0,
    hasMoved: false
};

// --- Physics Constants ---
const GRAVITY = -9.8; 
const DAMPING = 0.3;  
const BOX_BOUNDS = { x: 2.0, y: 1.0, z: 2.0 }; 
const PUSHSTRENGHT = 0.1
const MOUSE_INTERACTION_RADIUS = 0.05; 
const MOUSE_FORCE_MULTIPLIER = 0.05; 

// --- Light Constants ---
const LIGHT_POSITION = [0.0, 3.0, 0.0];

function ResetPositions() {
    if (meshInstances.length === 0) return;

    for (var i = 0; i < meshInstances.length; i++) {
        const newInstanceData = CreateInstance(); // Creates a new ball at a random position
        const ballToReset = meshInstances[i];
        
        // Copy the new random position to the existing ball
        vec3.copy(ballToReset.position, newInstanceData.position);
        
        // Reset velocity and acceleration to zero
        vec3.zero(ballToReset.velocity);
        vec3.zero(ballToReset.acceleration);
        
        // Reset color
        ballToReset.color = newInstanceData.color;
    }
}

function CreateInstance() {
    const x = (Math.random() - 0.5) * 3.8; 
    const y = (Math.random() * 0.9) + 0.1;   
    const z = (Math.random() - 0.5) * 3.8; 
    const redColor = [1.0, 0.2, 0.2, 1.0];
    const blueColor = [0.2, 0.5, 1.0, 1.0];
    const instanceColor = Math.random() < 0.5 ? redColor : blueColor;

    // Use the new Ball class!
    return new Ball(x, y, z, SPHERE_RADIOUS, instanceColor);
}


function InitWebGL()
{
	canvas = document.getElementById("canvas");
	canvas.oncontextmenu = function() {return false;};
	gl = canvas.getContext("webgl", {antialias: false, depth: true});	
	if (!gl) {
		alert("Unable to initialize WebGL. Your browser or machine may not support it.");
		return;
	}
	gl.clearColor(0,0,0,0); 
	gl.enable(gl.DEPTH_TEST);
	boxDrawer  = new BoxDrawer();
	ballDrawer = new BallDrawer();
	UpdateCanvasSize();
}

function UpdateCanvasSize()
{
	canvas.style.width   = "100%";
	canvas.style.height = "100%";
	const pixelRatio = window.devicePixelRatio || 1;
	canvas.width  = pixelRatio * canvas.clientWidth;
	canvas.height = pixelRatio * canvas.clientHeight;
	const width  = (canvas.width  / pixelRatio);
	const height = (canvas.height / pixelRatio);
	canvas.style.width  = width  + 'px';
	canvas.style.height = height + 'px';
	gl.viewport( 1, 1, canvas.width, canvas.height );
	UpdateProjectionMatrix();
}

function UpdateProjectionMatrix()
{
	const r = canvas.width / canvas.height;
	let n = (transZ - 5);
	const min_n = 0.001;
	if ( n < min_n ) n = min_n;
	const f = (transZ + 5);
	const fov = 3.145 * 60 / 180;
	
    // Use gl-matrix to create the perspective matrix
    mat4.perspective(perspectiveMatrix, fov, r, n, f);
}

function updateMouseState(deltaTime) {
    if (mouseState.x < 0 || !viewProjMatrix) return; 

    const ndcX = (mouseState.x / gl.canvas.clientWidth) * 2 - 1;
    const ndcY = 1 - (mouseState.y / gl.canvas.clientHeight) * 2; 

    const invMatrix = invertMatrix(viewProjMatrix);
    if (!invMatrix) return;

    // Use gl-matrix to unproject mouse coordinates from screen space to world space
    const worldNear = vec3.create();
    const worldFar = vec3.create();
    vec3.transformMat4(worldNear, [ndcX, ndcY, -1.0], invMatrix);
    vec3.transformMat4(worldFar, [ndcX, ndcY, 1.0], invMatrix);

	//solving the equation for y = -0.95 or the lower floor of the box
    const rayDirY = worldFar[1] - worldNear[1];
    if (Math.abs(rayDirY) < 0.0001) return; 
    const t = (-0.95 - worldNear[1]) / rayDirY; 


    const worldPos = vec3.create();
    const rayDir = vec3.create();
    vec3.subtract(rayDir, worldFar, worldNear);
    vec3.scaleAndAdd(worldPos, worldNear, rayDir, t);
	
	mouseState.worldX = worldPos[0];
    mouseState.worldY = worldPos[1];
	mouseState.worldZ = worldPos[2]; 
	
	if (mouseState.hasMoved && deltaTime > 0) {
		mouseState.velX = (mouseState.worldX - mouseState.lastWorldX) / deltaTime;
        // No vertical mouse velocity needed for this interaction
		mouseState.velZ = (mouseState.worldZ - mouseState.lastWorldZ) / deltaTime; 
	}

	mouseState.lastWorldX = mouseState.worldX;
	mouseState.lastWorldZ = mouseState.worldZ; 
	mouseState.hasMoved = true;
}

function DrawScene()
{
	if (!ballDrawer || !boxDrawer) return;

	viewMatrix = ViewMatrix( 0, 0, transZ, rotX, rotY )
	viewProjMatrix = ViewProjectionMatrix( perspectiveMatrix, 0, 0, transZ, rotX, rotY );
	
	if (ballDrawer.numIndices > 0) { 
		for (var i = 0; i < meshInstances.length ; i++) {
			var inst = meshInstances[i];
            // Access position from the Ball object's vec3 property
			var transM = TranslationMatrix(inst.position[0], inst.position[1], inst.position[2]); 
			ballDrawer.draw(viewProjMatrix, viewMatrix, transM, inst.color, LIGHT_POSITION);
		}
	}
	
	boxDrawer.draw(viewProjMatrix);
}

function InitShaderProgram( vsSource, fsSource )
{
	const vs = CompileShader( gl.VERTEX_SHADER,   vsSource );
	const fs = CompileShader( gl.FRAGMENT_SHADER, fsSource );
	const prog = gl.createProgram();
	gl.attachShader(prog, vs);
	gl.attachShader(prog, fs);
	gl.linkProgram(prog);
	if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
		alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(prog));
		return null;
	}
	return prog;
}

function CompileShader( type, source )
{
	const shader = gl.createShader(type);
	gl.shaderSource(shader, source);
	gl.compileShader(shader);
	if (!gl.getShaderParameter( shader, gl.COMPILE_STATUS) ) {
		alert('An error occurred compiling shader:\n' + gl.getShaderInfoLog(shader));
		gl.deleteShader(shader);
		return null;
	}
	return shader;
}

window.onload = function() {
	InitWebGL();
    meshInstances = []; 
    for (var i = 0; i < NUM_INSTANCES; i++) {
        meshInstances.push(CreateInstance());
    }
	
    // We only need to track mouse position when it moves over the canvas
    canvas.onmousemove = function(event) {
        const rect = canvas.getBoundingClientRect();
        mouseState.x = event.clientX - rect.left;
        mouseState.y = event.clientY - rect.top;
    };

	canvas.zoom = function( s ) {
		transZ *= s/canvas.height + 1;
		UpdateProjectionMatrix();
	}
	canvas.onwheel = function() { canvas.zoom(0.3*event.deltaY); } 
	canvas.onmousedown = function() {
		var cx = event.clientX;
		var cy = event.clientY;
		if ( event.ctrlKey ) {
			canvas.onmousemove = function() {
				canvas.zoom(5*(event.clientY - cy));
				cy = event.clientY;
			}
		} else {
			canvas.onmousemove = function() {
				rotY += (event.clientX- cx)/canvas.width*5;
				rotX += (event.clientY- cy)/canvas.height*5;
				cx = event.clientX;
				cy = event.clientY;
			}
		}
	}
	canvas.onmouseup = canvas.onmouseleave = function(event) {
        // Keep tracking mouse position on leave/up, just stop camera movement
        canvas.onmousemove = function(event) {
            const rect = canvas.getBoundingClientRect();
            mouseState.x = event.clientX - rect.left;
            mouseState.y = event.clientY - rect.top;
        };
	}
	
	requestAnimationFrame(Animate);
};

function WindowResize() { UpdateCanvasSize(); }

function Animate(currentTime) {
	requestAnimationFrame(Animate);
    currentTime *= 0.001;
    const deltaTime = lastTime > 0 ? currentTime - lastTime : 1/60; 
    lastTime = currentTime;

    updateMouseState(deltaTime);
    UpdatePhysics(deltaTime);
    DrawScene();
}

</script>
</body>
</html>