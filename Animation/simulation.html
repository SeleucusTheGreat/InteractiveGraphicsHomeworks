<!doctype html>
<html>
<head>
<title>WebGL Physics Spheres</title>
<link rel="stylesheet" href="style.css">
</head>
<body onresize="WindowResize()">
<div style="position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(255,255,255,0.8); padding: 5px; border-radius: 5px;">
    <div>
        <label for="numInstancesInput">Number of balls:</label>
        <input type="number" id="numInstancesInput" value="100" min="1" max="1000" style="width: 60px;">
        <button onclick="ResetSimulation()">Spawn/Reset Balls</button>
    </div>
</div>
<div id="canvas-div"><canvas id="canvas"></canvas></div>
</div>
<script type="text/javascript" src="gl-matrix.js"></script>
<script type="text/javascript" id="includedscript" src="matrix.js"></script>
<script type="text/javascript" id="includedscript" src="box.js"></script>
<script type="text/javascript" src="ball_drawer.js"></script>
<script type="text/javascript" src="physics.js"></script>
<script type="text/javascript" src="ball.js"></script>
<script type="text/javascript">

const { mat4, vec3, vec4 } = glMatrix;
	
var meshInstances = [];
var boxDrawer;
var ballDrawer;
var canvas, gl;
var perspectiveMatrix = mat4.create();	
var rotX=0, rotY=0, transZ=5 
var lastTime = 0; 

var viewProjMatrix; 
var viewMatrix; 
const mouseState = {
    x: -1, y: -1,     
    worldX: 0, worldY: 0, worldZ: 0,
    velX: 0, velY: 0, velZ: 0,
    lastWorldX: 0, lastWorldY: 0, lastWorldZ: 0,
    hasMoved: false
};

// --- Physics Constants ---
const GRAVITY = -9.8; 
const BOX_BOUNDS = { x: 2.0, y: 1.0, z: 2.0 }; 
const PUSHSTRENGHT = 0.1
const MOUSE_INTERACTION_RADIUS = 0.05; 
const MOUSE_IMPULSE_MULTIPLIER = 0.05; 
const RESTITUTION = 0.5; // Coefficient of bounciness. 1 = perfectly elastic, 0 = no bounce.

// --- Light Constants ---
const LIGHT_POSITION = [0.0, 3.0, 0.0];

function ResetSimulation() {
    const numInstancesInput = document.getElementById('numInstancesInput');
    let numToSpawn = parseInt(numInstancesInput.value, 10);

    // Basic validation to ensure the number is within reasonable bounds
    const minVal = parseInt(numInstancesInput.min, 10) || 1;
    const maxVal = parseInt(numInstancesInput.max, 10) || 5000;

    if (isNaN(numToSpawn) || numToSpawn < minVal) {
        numToSpawn = minVal;
        numInstancesInput.value = minVal;
    }
    if (numToSpawn > maxVal) {
        numToSpawn = maxVal;
        numInstancesInput.value = maxVal;
    }

    // Clear old instances and create new ones
    meshInstances = []; 
    for (var i = 0; i < numToSpawn; i++) {
        meshInstances.push(CreateInstance());
    }
}

function CreateInstance() {
    const x = (Math.random() - 0.5) * 3.8; 
    const y = (Math.random() * 0.9) + 0.1;   
    const z = (Math.random() - 0.5) * 3.8; 

    let radius, color, density;
    const rand = Math.random(); // Generate one random number to decide the ball type

    

    // --- 50% chance for a Blue Ball ---
    if (rand < 0.50) { 
        // Lighter, smaller blue balls
        radius = 0.08; 
        density = 15; 
        color = [0.2, 0.5, 1.0, 1.0]; // Blue
    } 
    
    // --- 35% chance for a Red Ball ---
    else if (rand < 0.85) { 
        // Heavy, large red balls
        radius =  0.12
        density = 60;
        color = [1.0, 0.2, 0.2, 1.0]; // Red
    } 
    
    // --- 15% chance for a Green Ball ---
    else { 
        // Medium density, fast green balls
        radius = 0.15
        density = 60; // Medium density
        color = [0.2, 1.0, 0.3, 1.0]; // Green
    }

    // Use the Ball class to create the physics object with the chosen properties
    return new Ball(x, y, z, radius, color, density);
}


function InitWebGL()
{
	canvas = document.getElementById("canvas");
	canvas.oncontextmenu = function() {return false;};
	gl = canvas.getContext("webgl", {antialias: false, depth: true});	
	if (!gl) {
		alert("Unable to initialize WebGL. Your browser or machine may not support it.");
		return;
	}
	gl.clearColor(0,0,0,0); 
	gl.enable(gl.DEPTH_TEST);
	boxDrawer  = new BoxDrawer();
	ballDrawer = new BallDrawer();
	UpdateCanvasSize();
}

function UpdateCanvasSize()
{
	canvas.style.width   = "100%";
	canvas.style.height = "100%";
	const pixelRatio = window.devicePixelRatio || 1;
	canvas.width  = pixelRatio * canvas.clientWidth;
	canvas.height = pixelRatio * canvas.clientHeight;
	const width  = (canvas.width  / pixelRatio);
	const height = (canvas.height / pixelRatio);
	canvas.style.width  = width  + 'px';
	canvas.style.height = height + 'px';
	gl.viewport( 1, 1, canvas.width, canvas.height );
	UpdateProjectionMatrix();
}

function UpdateProjectionMatrix()
{
	const r = canvas.width / canvas.height;
	let n = (transZ - 5);
	const min_n = 0.001;
	if ( n < min_n ) n = min_n;
	const f = (transZ + 5);
	const fov = 3.145 * 60 / 180;
	
    // Use gl-matrix to create the perspective matrix
    mat4.perspective(perspectiveMatrix, fov, r, n, f);
}

function updateMouseState(deltaTime) {
    if (mouseState.x < 0 || !viewProjMatrix) return; 

    const ndcX = (mouseState.x / gl.canvas.clientWidth) * 2 - 1;
    const ndcY = 1 - (mouseState.y / gl.canvas.clientHeight) * 2; 

    const invMatrix = invertMatrix(viewProjMatrix);
    if (!invMatrix) return;

    // Use gl-matrix to unproject mouse coordinates from screen space to world space
    const worldNear = vec3.create();
    const worldFar = vec3.create();
    vec3.transformMat4(worldNear, [ndcX, ndcY, -1.0], invMatrix);
    vec3.transformMat4(worldFar, [ndcX, ndcY, 1.0], invMatrix);

	//solving the equation for y = -0.95 or the lower floor of the box
    const rayDirY = worldFar[1] - worldNear[1];
    if (Math.abs(rayDirY) < 0.0001) return; 
    const t = (-0.95 - worldNear[1]) / rayDirY; 


    const worldPos = vec3.create();
    const rayDir = vec3.create();
    vec3.subtract(rayDir, worldFar, worldNear);
    vec3.scaleAndAdd(worldPos, worldNear, rayDir, t);
	
	mouseState.worldX = worldPos[0];
    mouseState.worldY = worldPos[1];
	mouseState.worldZ = worldPos[2]; 
	
	if (mouseState.hasMoved && deltaTime > 0) {
		mouseState.velX = (mouseState.worldX - mouseState.lastWorldX) / deltaTime;
		mouseState.velZ = (mouseState.worldZ - mouseState.lastWorldZ) / deltaTime; 
	}

	mouseState.lastWorldX = mouseState.worldX;
	mouseState.lastWorldZ = mouseState.worldZ; 
	mouseState.hasMoved = true;
}

function DrawScene()
{
	if (!ballDrawer || !boxDrawer) return;

	viewMatrix = ViewMatrix( 0, 0, transZ, rotX, rotY )
	viewProjMatrix = ViewProjectionMatrix( perspectiveMatrix, 0, 0, transZ, rotX, rotY );
	
	if (ballDrawer.numIndices > 0) { 
		for (var i = 0; i < meshInstances.length ; i++) {
			const inst = meshInstances[i];

            // 1. Create translation matrix from the ball's position
			const transM = TranslationMatrix(inst.position[0], inst.position[1], inst.position[2]); 
            // 2. Create scaling matrix from the ball's radius
            const scaleM = ScalingMatrix(inst.radius, inst.radius, inst.radius);
            // 3. Combine them into a single model matrix
            const modelM = MatrixMult(transM, scaleM);
            
            // 4. Draw the ball using its unique properties and the calculated model matrix
			ballDrawer.draw(viewProjMatrix, viewMatrix, modelM, inst.color, LIGHT_POSITION);
		}
	}
	
	boxDrawer.draw(viewProjMatrix);
}

function InitShaderProgram( vsSource, fsSource )
{
	const vs = CompileShader( gl.VERTEX_SHADER,   vsSource );
	const fs = CompileShader( gl.FRAGMENT_SHADER, fsSource );
	const prog = gl.createProgram();
	gl.attachShader(prog, vs);
	gl.attachShader(prog, fs);
	gl.linkProgram(prog);
	if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
		alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(prog));
		return null;
	}
	return prog;
}

function CompileShader( type, source )
{
	const shader = gl.createShader(type);
	gl.shaderSource(shader, source);
	gl.compileShader(shader);
	if (!gl.getShaderParameter( shader, gl.COMPILE_STATUS) ) {
		alert('An error occurred compiling shader:\n' + gl.getShaderInfoLog(shader));
		gl.deleteShader(shader);
		return null;
	}
	return shader;
}

window.onload = function() {
	InitWebGL();
    ResetSimulation(); // Initialize the simulation with the default number of balls
	
    // We only need to track mouse position when it moves over the canvas
    canvas.onmousemove = function(event) {
        const rect = canvas.getBoundingClientRect();
        mouseState.x = event.clientX - rect.left;
        mouseState.y = event.clientY - rect.top;
    };

	canvas.zoom = function( s ) {
		transZ *= s/canvas.height + 1;
		UpdateProjectionMatrix();
	}
	canvas.onwheel = function() { canvas.zoom(0.3*event.deltaY); } 
	canvas.onmousedown = function() {
		var cx = event.clientX;
		var cy = event.clientY;
		if ( event.ctrlKey ) {
			canvas.onmousemove = function() {
				canvas.zoom(5*(event.clientY - cy));
				cy = event.clientY;
			}
		} else {
			canvas.onmousemove = function() {
				rotY += (event.clientX- cx)/canvas.width*5;
				rotX += (event.clientY- cy)/canvas.height*5;
				cx = event.clientX;
				cy = event.clientY;
			}
		}
	}
	canvas.onmouseup = canvas.onmouseleave = function(event) {
        // Keep tracking mouse position on leave/up, just stop camera movement
        canvas.onmousemove = function(event) {
            const rect = canvas.getBoundingClientRect();
            mouseState.x = event.clientX - rect.left;
            mouseState.y = event.clientY - rect.top;
        };
	}
	
	requestAnimationFrame(Animate);
};

function WindowResize() { UpdateCanvasSize(); }

function Animate(currentTime) {
	requestAnimationFrame(Animate);
    currentTime *= 0.001;
    const deltaTime = lastTime > 0 ? currentTime - lastTime : 1/60; 
    lastTime = currentTime;

    updateMouseState(deltaTime);
    UpdatePhysics(deltaTime);
    DrawScene();
}

</script>
</body>
</html>